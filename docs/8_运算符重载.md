## 运算符重载

### 概述

通过给函数增加 operator 属性来定义一个函数，并告诉编译器，对于符合函数入参规则的该运算符需调用此函数来行使运算符功能。这个函数也叫做运算符的重载函数。

### 代码示例

```c++
#include <assert.h>
struct square
{
    int width;
    int height;
};

// 运算符‘+’号重载函数
__attribute__((operator +))
struct square squareAdd(struct square s1, struct square s2){
    struct square s = {s1.width + s2.width, s1.height + s2.height};
    return s;
}

int main(){
    struct square s1 = {100, 50};
    struct square s2 = {60, 110};
    // 在之前我们必须主动调用函数来完成结构体运算操作。
    struct square s3 = squareAdd(s1, s2);
    assert(s3.width == 160);
    assert(s3.height == 160);
	// 将函数加上重载标记后，现在我们可以直接对该结构体进行运算操作。
    struct square s4 = s1 + s2;
    assert(s4.width == 160);
    assert(s4.height == 160);
    return 0;
}
```

### 语法规则

1、在普通函数基础上，通过 `__attribute__((operator Op))` 属性标记该函数为运算符重载函数。

```c
__attribute__((operator OP)) function-declaration
```

代码示例：

```c
// 定义了一个“+”号运算符重载函数 
__attribute__((operator +))
struct square squareAdd(struct square s1, struct square s2){
    struct square s = {s1.width + s2.width, s1.height + s2.height};
    return s;
}
```
2、运算符重载函数只能是全局函数，不允许标记成员函数、`trait`声明的函数为重载函数。

3、支持重载的运算符列表。

| 类别           | 运算符                                                       |
| -------------- | ------------------------------------------------------------ |
| 双目算术运算符 | + (加)，- (减)，* (乘)，/ (除)，% (取模)                     |
| 关系运算符     | == (等于)，!= (不等于)，< (小于)，> (大于)，<= (小于等于)，>= (大于等于) |
| 位运算符       | \| (按位或)，& (按位与)，~ (按位取反)，^ (按位异或),，<< (左移)，>> (右移) |
| 单目运算符     | \+ (正)，- (负)，* (解引用)                                  |
| 成员访问运算符 | ->                                                           |
| 索引运算符     | []                                                           |

4、运算符重载函数入参和返回值要求。

| 运算符           | 入参要求     | 返回值要求                                                |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 关系运算符 | 只允许有两个入参, 且至少有一个参数是用户自定义类型，如结构体、枚举。 | 返回值类型必须是_Bool类型         |
| *(解引用), <br />-> (成员访问运算符) | 只允许有一个入参,且第一个参数为用户自定义类型的指针类型，包括裸指针、可变借用指针、不可变借用指针。 | 返回值类型必须是指针类型，包括裸指针、可变借用指针、不可变借用指针、Rc指针。 |
| [] (索引运算符) | 只允许有两个入参,且第一个参数为用户自定义类型的指针类型，包括裸指针、可变借用指针、不可变借用指针。 | 返回值类型必须是指针类型，包括裸指针、可变借用指针、不可变借用指针、Rc指针。 |
| 其他     | 单目运算符只允许有一个入参, 双目运算符值只允许有两个入参。函数至少有一个入参是用户自定义类型。 | 无                              |

- 关系运算符重载代码示例

    ```c
    #include <assert.h>
    struct Foo {
        int x;
        int y;
    };

    __attribute__((operator >))
    _Bool FooCompare(struct Foo A, struct Foo B) {  // 参数至少有一个是用户自定义类型
        return A.y > B.y;
    };

    int main() {
        struct Foo f1 = {180, 18};
        struct Foo f2 = {166, 22};
        assert(f2 > f1 && "compare error");
        return 0;
    }
    ```

- 解引用运算符重载代码示例

    ```c
    #include <assert.h>
    struct MyPoint<T> {
        T * data;
    };
    
    __attribute__((operator *))
    T * derefMyPoint<T>(struct MyPoint<T> * borrow p) {  // 入参和返回值必须是指针类型。
        return p->data;
    }
    
    int main() {
        int data = 100;
        struct MyPoint<int> p = {&data};
        // 编译器匹配到重载函数后，自动对p取地址并传入重载函数，并对函数返回值做解引用。此处等效为(*derefMypoint(&mut p)) == 100。
        assert(*p == 100);
        *p = 10;
        assert(*p == 10);
        return 0;
    }
    ```

- 成员访问运算符重载代码示例

    ```c
    #include <assert.h>
    struct MyData<T> {
        T a;
    };
    struct MyPoint<T> {
        MyData<T>* data;
    };
    
    __attribute__((operator ->))
    MyData<T> * mDerefMyPoint<T>(struct MyPoint<T> * borrow p) {   // 入参和返回值必须是指针类型。
        return p->data;
    }
    
    int main() {
        struct MyData<int> d = {100};
        struct MyPoint<int> p = {&d};
        assert(p->a == 100);   // 编译器匹配到重载函数后，自动对p取地址并传入重载函数。此处等效为mDerefMyPoint(&mut p)->a == 100。
        p->a = 10;
        assert(p->a == 10);
        return 0;
    }
    ```

-  索引运算符重载代码示例

    ```c
    #include <assert.h>
    #define ARRLEN 10
    struct MyArray<T> {
        T data[ARRLEN];
    };
    
    __attribute__((operator []))
    T * GetMyArrayData<T>(struct MyArray<T> * p, int index) {
        return &p->data[index];
    }
    
    int main() {
        struct MyArray<int> array;
        for (int i = 0; i < ARRLEN; i++) {
            // 编译器匹配到重载函数后，自动对p取地址并传入重载函数,并对函数返回值做解引用。此处等效为*GetMyArrayData(&mut p, i) = i。
    		array[i] = i;
        }
        assert(array[5] == 5);
        return 0;
    }
    ```
    
-  运算符重载错误代码示例

    ```c
    // error: 不允许定义无用户自定义入参类型的运算符重载函数。
    __attribute__((operator +))
    int squareAdd(int a, int b){
        return a + b;
    }
    ```

5、运算符重载函数名不能与普通函数名冲突。对同一个运算符定义多个重载函数时，如果函数名不同并且参数类型不完全一致，允许同时存在。

```c
__attribute__((operator +))
struct square squareAdd(struct square s1, struct square s2){
    /* code */
}
// 支持对同一个运算符多次重载
__attribute__((operator +))
struct oblong oblongAdd(struct oblong s1, struct oblong s2){
    /* code */
}
```

7、运算符重载函数可以是泛型函数。

```c
#include <stdio.h>

struct Point<T>
{
    T x;
    T y;
};

__attribute__((operator +))
struct Point<T> Add<T>(struct Point<T> lhs, struct Point<T> rhs){
  T x1 = lhs.x + rhs.x;
  T y1 = lhs.y + rhs.y; 
  struct Point<T> p = {.x = x1, .y = y1};
  return p;
}

__attribute__((operator *))
struct Point<T> Mul<T>(struct Point<T> lhs, struct Point<T> rhs){
  T x1 = lhs.x * rhs.x; 
  T y1 = lhs.y * rhs.y; 
  struct Point<T> p = {.x = x1, .y = y1};
  return p;
}

void test1() {
  struct Point<int> p1 = {.x = 1, .y = 2};
  struct Point<int> p2 = {.x = 3, .y = 4};
  struct Point<int> p3 = p1 + p2; // {.x = 4, .y = 6}
  printf("p3.x: %d, p3.y :%d\n", p3.x, p3.y);  
}

void test2() {
  struct Point<int> p1 = {.x = 1, .y = 2};
  struct Point<int> p2 = {.x = 3, .y = 4};
  struct Point<int> p3 = p1 * p2; // {.x = 3, .y = 8}
  printf("p3.x: %d, p3.y :%d\n", p3.x, p3.y);  
}

int main() {
  test1();
  test2();
}
```
