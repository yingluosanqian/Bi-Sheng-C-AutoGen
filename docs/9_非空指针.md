## 非空指针
为了提高指针使用的安全性，BSC 为指针引入了可空（Nullable）和非空（Nonnull）属性：
1. 使用`_Nullable`关键字修饰任意指针类型（包括裸指针、owned和borrow指针），表明该指针是可空指针。
2. 使用`_Nonnull`关键字修饰任意指针类型，表明该指针是非空指针。
在使用指针时，BSC 编译器会（在编译期）对指针的 nullability 进行检查，避免出现解引用空指针、通过空指针访问成员等不安全行为。

BSC 不允许在安全区内使用`NULL`，但是在日常开发中，空指针的使用是不可避免的，例如：
1. 一个指针的指向需要在运行时才能确定，那么我们可以将指针初始化为空指针，在后续再根据运行状态来修改指向
2. 对于可空指针，在使用前需要判断该指针是否为空指针
为此 BSC 引入了`nullptr`关键字来替代`NULL`，用户可以定义 Nullable 指针，并将其初始化为`nullptr`，在解引用 Nullable 指针前，也可以使用`nullptr`对指针判空。

我们用一个简单的例子来学习如何定义指针的 nullabiliy 并使用它：
```C
#include "bishengc_safety.hbs"

safe int get_current_status(void);  // 获取当前运行状态的函数

struct Data {
    int value;
};

// 如果 init 成功，返回具体的地址，否则返回 nullptr
safe struct Data *owned _Nullable init_data(void) {
    if (get_current_status() == 1) {
        struct Data data = { 10 };
        struct Data *owned p = safe_malloc<struct Data>(data);
        return p;
    }
    return nullptr;
}

safe void read_data(struct Data *borrow p);

safe int main(void) {
    // 使用 _Nullable 修饰指针类型：
    struct Data *owned _Nullable p = init_data();
    // init 后 p 可能为空指针，因此需要先判空再使用：
    if (p != nullptr) {
        read_data(&mut *p);  // 如果没有对 p 做判空，编译器会报 error!
        safe_free((void *owned)p);
    }
    return 0;
}
```

### 指针变量的 Nullability
指针变量的默认 Nullability 跟 qualifier 和指针类型有关：
1. 如果有 qualifier(`_Nonnull`或`_Nullable`)修饰，以这个为准
2. 如果没有 qualifier 修饰，裸指针默认是 Nullable 的，owned 和 borrow 指针默认是 Nonnull 的
```C
// Nullable 指针：
int *_Nullable p1 = nullptr;       
int *borrow _Nullable p2 = nullptr;
int *owned _Nullable p3 = nullptr;
int * p4 = nullptr;
// Nonnull 指针：
int *_Nonnull p5 = &a;
int *borrow _Nonnull p6 = &mut a;
int *owned _Nonnull p7 = safe_malloc<int>(5);
int *borrow p8 = &mut a;
int *owned p9 = safe_malloc<int>(5);
```

对于 Nonnull 指针，它的 Nullability 一定是 Nonnull 的。
对于 Nullable 指针，它的 Nullability 可能会发生变化：
1. 如果用非空表达式对其进行了赋值，那么在这条赋值语句后面可以把它当做 Nonnull 指针使用
2. 如果在控制流语句中对其做了判空，那么在非空的分支中，可以把它当做 Nonnull 指针使用

```C
safe int *borrow _Nullable nullable(int* borrow p);  //返回值类型为 Nullable 的
safe int *borrow nonnull(int* borrow p);             //返回值类型为 Nonnull 的

safe void test(void) {
    int local = 10;
    int *borrow _Nullable p1 = nullptr; // p1 初始化后 Nullability 为 Nullable
    *p1 = 10;                           // error
    p1 = &mut local;                    // p1 被再赋值后 Nullability 变为 Nonnull
    *p1 = 20;                           // ok
    p1 = nullable(&mut local);          // p1 被再赋值后 Nullability 变为 Nullable
    *p1 = 20;                           // error
    p1 = nonnull(&mut local);           // p1 被再赋值后 Nullability 变为 Nonnull
    *p1 = 20;                           // ok

    int *borrow _Nullable p2 = nullable(&mut local); // Nullable
    if (p2 != nullptr)     // if 分支中 p2 的 Nullability 为 Nonnull
        *p2 = 10;          // ok
    else                   // else 分支中 p2 的 Nullability 为 Nullable
        *p2 = 20;          // error
}
```

### 指针的赋值、传参和返回
1. 不允许用可空表达式给 Nonnull 指针赋值：
```C
safe int *borrow _Nullable nullable(int* borrow p);  //返回值类型为 Nullable
safe int *borrow nonnull(int* borrow p);             //返回值类型为 Nonnull

safe void test(void) {
    int local = 10;
    int *borrow p1 = nullptr;               // error
    int *borrow p2 = nullable(&mut local);  // error
    int *borrow p3 = nonnull(&mut local);   // ok

    int *borrow _Nullable p4 = nullable(&mut local); // p4 的 Nullability 是 Nullable
    int *borrow p5 = p4;                    // error

    int *borrow _Nullable p6 = nonnull(&mut local);  // p6 的 Nullability 是 Nonnull
    int *borrow p7 = p6;                    // ok
}
```

2. 函数调用时，如果形参为 Nonnull 类型，那么不能使用用可空表达式作为实参：
```C
safe void take_nonnull(int *borrow p);  // 接收 Nonnull 类型的指针作为参数
safe int *borrow _Nullable nullable(int* borrow p);  // 返回值类型为 Nullable

safe void test(void) {
    int local = 10;
    int *borrow _Nullable p = nullable(&mut local);
    take_nonnull(p);       // error
}
```

3. 函数返回值类型如果是 Nonnull 类型，也不能使用可空表达式作为返回值：
```C
safe int *borrow return_nonnull(int *borrow p) {
    int *borrow _Nullable q = nullptr;
    return q;              // error
}
```

### 指针的解引用、成员访问
被定义为 Nullable 的指针的 Nullability 会随赋值和控制流发生变化，BSC 编译器会跟踪这些变换，保证指针解引用、成员访问等操作的安全性。
```C
struct Data {
    int value;
};
safe struct Data *borrow _Nullable nullable(struct Data *borrow);

safe void test(void) {
    struct Data data = { .value = 10 };
    struct Data *borrow _Nullable p = nullable(&mut data);
    if (p != nullptr) {
        p->value = 10;         // ok，如果没有判空操作，编译器会报 error
    }
}
```

### 结构体成员是 Nullable 指针
初始化有 Nullable 指针成员的结构体变量时：
1. 如果是通过初始化列表进行初始化，BSC 编译器会根据初始化表达式来初始化 Nullable 指针成员的 Nullability
2. 对于其它初始化方式，直接认为 Nullable 指针成员的 Nullability 为 Nullable 的，这可能会导致本身没有问题的代码无法通过编译，此时需要对 Nullable 指针成员作再赋值，或使用判空语句，即可改变 Nullability。
```C
struct Data { int *borrow _Nullable value; };

safe struct Data init_data(int* borrow p);
safe int *borrow nonnull(int* borrow p);

safe void test(void) {
    int local = 10;
    // 使用初始化列表做初始化：
    struct Data data1 = { .value = nonnull(&mut local) };// data1.value 的 Nullability 是 Nonnull
    *data1.value = 10;              // ok
    // 使用函数返回值做初始化：
    struct Data data2 = init_data(&mut local);           // data2.value 的 Nullability 是 Nullable
    *data2.value = 10;              // error
    // 使用变量赋值做初始化：
    struct Data data3 = data1;      // data3.value 的 Nullability 是 Nullable
    *data3.value = 10;              // error

    // 对 Nullable 指针成员作再赋值，可以改变 Nullability：
    data2.value = nonnull(&mut local);
    *data2.value = 10;              // ok
    // 通过指针判空语句，也可以改变 Nullability：
    if (data3.value != nullptr)
        *data2.value = 10;          // ok
}
```
### 非空指针检查的范围和控制选项

非空指针检查是一项强大的功能，能帮助开发者在编译期识别出潜在的危险行为。同时，这会带来一定的编译性能开销和编码行为限制。默认情况下，对非空指针的检查仅在安全区生效，安全区的定义详见[内存安全-安全区](#安全区)章节。

在非安全区，我们将是否开启非空指针检查的选择权交给开发者，即通过编译选项`-nullability-check=value`来控制该项检查的作用域。其中`value`是一个枚举值，有3种选项`none`, `onlysafe`, `all`：

1. `value`的默认值为`safeonly`，控制着检查只在安全区生效；无该编译选项时，等同`-nullability-check=safeonly`。
2. `value`值为`none`时，将整体禁用非空指针检查，安全区与非安全区均不做检查。
3. `value`值为`all`时，将整体使能非空指针检查，安全区与非安全区均开启检查。

提供一个示例说明：

```C
safe void nullptrTest(void) {
  int *borrow _Nullable p = nullptr;
  {
    unsafe {
      *p = 10; // error1: nullable pointer cannot be dereferenced
    }
  }
  *p = 5; // error2: nullable pointer cannot be dereferenced
}
```
对于上面这个示例，当编译选项`-nullability-check`不存在或者`-nullability-check=safeonly`时，只有在`safe`区的`error2`会被报告；当`-nullability-check=none`时，`error1`和`error2`均不会被报告；当`-nullability-check=all`时，非安全区的`error1`和安全区`error2`均会被报告。
