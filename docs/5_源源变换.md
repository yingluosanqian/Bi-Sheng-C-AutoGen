## 源源变换

### 概述

对于一个毕昇 C 源代码文件，通常情况下只需要使用毕昇 C 编译器直接将其编译为对应的二进制代码并运行。
毕昇 C 编译器也提供了将编写的毕昇 C 源代码转换为等价的标准 C 代码的能力，该能力由编译选项`-rewrite-bsc`提供。
在编译时加上该编译选项后，编译会生成包含等价 C 代码的文件，该文件可再使用 gcc、clang 等编译器编译为目标代码。
一般而言，源源变换适用于如下场景：

1. 希望查看毕昇 C 代码对应的等价的 C 代码；
2. 基于现有的使用 C 语言开发的项目，使用毕昇 C 进行增量开发，但又希望依然使用原先的编译工具链进行编译；
3. 运行程序的目标平台不是毕昇 C 编译器所支持的标准后端时，也需要先将毕昇 C 代码转换为 C 代码，再使用支持目标平台的编译器编译 C 代码。

### 使用方式

毕昇 C 编译器的`-rewrite-bsc`编译选项的使用方式和 clang 原生的`-rewrite-objc`编译选项的用法相似。在编译想要被转换的毕昇 C 源码时加上`-rewrite-bsc`即可使用源源变换模式进行编译。

例如：如果你想要对`test.cbs`进行源源变换，那么在编译的时候使用如下命令即可在当前目录下得到一个名为`test.c`的 C 文件，文件的内容即为变换后的 C 源码。

```shell
clang -rewrite-bsc test.cbs
```

如果要变换的文件需要引用某些头文件，那么在源源变换时同样需要使用`-I`选项指定头文件搜索路径。例如如果`test.cbs`依赖于毕昇 C 标准库（后面的章节会具体说明），那么相应的编译命令为：

```shell
clang -rewrite-bsc test.cbs -I/path/to/libcbs/include
```

对于一个名为`xx.cbs`的毕昇 C 文件，源源变换生成的 C 文件的默认文件名为`xx.c`。
源源变换也支持使用`-o`指定输出的 C 文件名，如下示例就将源源变换生成的目标文件命名为`a.c`：

```shell
clang -rewrite-bsc test.cbs -o a.c
```

毕昇 C 编译器也支持同时对多个文件进行变换，不过多个文件同时变换时不支持通过`-o`指定输出的目录或名称，示例如下：

```shell
clang -rewrite-bsc boo.cbs foo.cbs
```

对于源源变换，还有以下几点需要说明和注意：

1. 使用源源变换模式进行编译时，编译器同样会像普通编译模式下那样先对要变换的文件进行词法、语法、语义的检查，对文件中的错误会编译报错，并且不会进行源源变换生成 C 文件。只有能正确通过编译的文件才会在源源变换模式下生成对应的 C 文件。
2. 对于非 cbs 后缀文件使用 -rewrite-bsc 选项，该选项会被忽略（除非添加`-x bsc`将文件按照毕昇 C 进行处理），并报如下 warning 。
    ```shell
    warning: ignoring '-rewrite-bsc' option because rewriting input type 'c' is not supported [-Woption-ignored]
    ```
3. 只需要对毕昇 C 源文件（cbs 文件）进行源源变换，不需要对毕昇 C 头文件（hbs 文件）进行变换。源源变换生成的 C 文件在后续编译时不再依赖任何 hbs 文件，原先 cbs 文件中依赖的 hbs 文件中的内容已经包含在了生成的 C 文件中。因此，可以直接编译生成的 C 文件并生成二进制代码。
4. 源源变换严格区分标准 C 头文件和 hbs 文件，但为方便用户使用，并不要求所有的 hbs 文件后缀名都为 .hbs。具体的区分规则为：
   - 以 .hbs 为后缀的是 hbs 文件
   - 以 .h 为后缀的头文件，且文件的第一行为`#pragma bsc`，则该文件也被视为 hbs 文件
   - 以 .h 为后缀的头文件，且该文件直接或间接包含了 hbs 文件，则该文件也被视为 hbs 文件

### 目标文件结构

对于源源变换，还需要对生成的 C 文件的结构进行说明。C 文件中的内容按照如下顺序排列：

1. 头文件包含。这里包含了所有需要引用的标准 C 的头文件，包括直接被 cbs 文件引用的头文件以及被 hbs 文件间接引用的头文件。由于 hbs 文件不再被目标文件依赖，因此目标代码中不会再包含对毕昇 C 头文件的引用。
2. 宏定义。这里包含了所有的 cbs 文件中定义的宏以及 cbs 文件引用的 hbs 文件中定义的宏。
3. 类型别名和枚举定义。这里包含了所有的类型别名定义以及枚举类型定义。如果一个类型别名是对 trait 的类型别名，那么它不会出现在目标文件中。如果一个类型别名是对匿名类型的类型别名，那么在目标文件中会为匿名类型加上 typedef 的类型别名作为类型名。如：
    ```c
    // 毕昇 C 文件中：
    typedef struct {
        char *buf;
        int len;
    } MSG;
    
    // 生成的 C 文件中：
    typedef struct _TD_MSG MSG;
    
    struct _TD_MSG {
        char *buf;
        int len;
    };
    ```
4. 类型定义。这里包含了所有 cbs 文件中以及 cbs 文件引用的 hbs 文件中的类型定义。由于毕昇 C 中有泛型类型，因此需要考虑到目标文件中类型定义的顺序问题。毕昇 C 编译器的源源变换采取的是一种类型拓扑排序的方案，保证在定义一个类型时，已经在前面包含了所有它依赖的类型的完整定义。如下用例展示了一个使用毕昇 C标准库构造出的`LinkedList<Vec<int>>`类型以及对应的目标文件中的类型定义顺序：
    ```c
    // 毕昇 C 文件中：
    #include "list.hbs"
    #include "vec.hbs"
    int main() {
        Vec<int> v1 = Vec<int>::new();
        Vec<int> v2 = Vec<int>::new();
        Vec<int> v3 = Vec<int>::new();
        for (int i = 0; i < 10; i = i + 1) {
            v1.push(i);
        }
        for (int i = 0; i < 10; i = i + 1) {
            v2.push(i);
        }
        for (int i = 0; i < 10; i = i + 1) {
            v3.push(i);
        }
        LinkedList<Vec<int>> l = LinkedList<Vec<int>>::new();
        l.push_back(v1);
        l.push_back(v2);
        l.push_back(v3);
        Vec<int> ele = l.pop_back();
        return 0;
    }
    
    // 编译命令：clang -rewrite-bsc main.cbs -I/path/to/libcbs/include
    // 生成的 C 文件中的类型定义（省略其他代码）：
    struct RawVec_int {
        int *ptr;
        size_t cap;
    };
    struct LinkedList_struct_Vec_int {
        struct _BSC_ListNode_struct_Vec_int *head;
        struct _BSC_ListNode_struct_Vec_int *tail;
        size_t len;
    };
    struct Vec_int {
        struct RawVec_int buf;
        size_t len;
    };
    struct _BSC_ListNode_struct_Vec_int {
        struct _BSC_ListNode_struct_Vec_int *next;
        struct _BSC_ListNode_struct_Vec_int *prev;
        struct Vec_int element;
    };
    ```
5. 泛型函数、泛型结构体的扩展成员函数的声明。
6. 非泛型函数的定义。
7. 泛型函数、泛型结构体扩展的成员函数的定义。

------
