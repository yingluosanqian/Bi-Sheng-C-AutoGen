## 标准库

### 安全 API

#### `safe_malloc`

`safe_malloc`是 BiShengC 语言提供的一个安全的内存分配函数。
该函数接收一个泛型类型`T`的变量，表示要分配的内存的大小以及分配后对内存的初始化。
该函数的返回值为`T * owned`类型，即指向分配好的堆内存的`owned`指针。
一些具体的使用例子如下。

在 C 语言中，如果我们需要申请一段堆内存，我们可以使用`malloc`函数进行分配，然后给该内存赋值，如：

```c
void example() {
    int *p = (int *)malloc(sizeof(int));
    *p = 2;
}
```

然而，这样分配的内存不会在`p`的作用域结束时检查是否调用了`free`进行释放，会造成内存泄漏。
此外，如果再使用一个指针也指向该内存，并在作用域结束时释放，则会出现重复释放的问题，如：

```c
void example() {
    int *p = (int *)malloc(sizeof(int));
    *p = 2;
    int *q = p;
    free(p);
    free(q); // error: double free!
}
```

使用 BiShengC 语言即可解决这种问题，相应的代码如下：

```c
safe void example(void) {
    int * owned p = safe_malloc(2);
    int * owned q = p;
    unsafe {
        safe_free((void * owned)q);
    }
}
```

在使用 BiShengC 语言改写后的代码中，如果我们在函数退出前什么都不做，则会出现编译错误`"memory leak of value: `q`"`，避免了内存泄漏问题的发生；
如果我们在函数退出前同时调用`safe_free((void * owned)p)`和`safe_free((void * owned)q)`，则会出现编译错误`"use of moved value: `p`"`，避免了重复释放问题的发生。

那么对于更为复杂的结构体类型，该如何正确使用`safe_malloc`进行内存分配呢？
对于结构体类型，需要首先在栈上构造出相应的变量，然后传给`safe_malloc`在堆上完成相应内存的分配，以下代码为具体示例：

```c
struct S {
    int * owned p;
    int * owned q;
};

safe void example(void) {
    struct S s = { .p = safe_malloc(1), .q = safe_malloc(2) };
    struct S * owned sp = safe_malloc(s);
    ...
}
```

#### `safe_free`

`safe_free`是 BiShengC 语言提供的一个安全的内存释放函数。
该函数接收一个`void * owned`类型的指针，表示要释放的内存的地址。
该函数的返回值为`void`类型。
因此，在调用`safe_free`进行释放前需要将`owned`指针显式地强制转换为`void * owned`类型，具体的转换规则可参考 [3.3](#33-强制类型转换) 节。
一些具体的使用例子如下。

```c
struct S {
    int * owned p;
    int * owned q;
};

safe void example(void) {
    int * owned pa = safe_malloc(199);
    struct S s = { .p = safe_malloc(1), .q = safe_malloc(2) };
    struct S * owned sp = safe_malloc(s);
    unsafe {
        safe_free((void * owned)pa);
        safe_free((void * owned)sp->p);
        safe_free((void * owned)sp->q);
        safe_free((void * owned)sp); // 必须先释放 sp->p 和 sp->q，才能释放 sp
    }
}
```

#### `safe_swap`

`safe_swap`是 BiShengC 语言提供的一个安全交换两个变量的值的函数。
该函数是一个泛型函数,接收两个类型为`T* borrow`类型的参数,即需要交换的变量的值的借用。
该函数的返回值为`void`类型,该 API 的主要作用为在交换两个变量的值时,同时能交换两个变量所拥有的所有权.
一个具体的使用例子如下。

```c
owned struct S {
public:
    int* owned p;
    int* owned q;
    ~S(S this) {
        safe_free((void* owned)this.p);
        safe_free((void* owned)this.q);
    }
};

safe void example(void) {
    S s1 = { .p = safe_malloc(1), .q = safe_malloc(2) };
    S s2 = { .p = safe_malloc(3), .q = safe_malloc(4) };
    safe_swap(&mut s1, &mut s2); // 交换后,s1.p为3,s1.q为4
}
```

#### `forget`

`forget` 主要用于获取变量的所有权并且“忘记”它，该函数是一个泛型函数，接收一个类型为泛型类型`T`的变量，表示要“忘记”的值：
1. 如果该变量是 owned 指针，那么该指针指向的内存不会被释放；
2. 如果该变量是 owned struct 类型，那么不会调用其析构函数。

在一些特殊的场景，用户希望取得变量的所有权而不通过该变量来释放管理的底层资源（如堆内存或文件句柄，这些资源可能已经通过裸指针操作被转移或释放），例如：

```c
#include "bishengc_safety.hbs"
#include <string.h>
owned struct Resource {
public:
    char *owned s;
    ~Resource(This this) {
        safe_free((void *owned)this.s);
    }
};

void get_resource(char* val) {
    Resource r = { .s = safe_malloc<char>(100) };
    memcpy(val, (const void *)&r, sizeof(Resource)); // Resource中的资源被转移
    forget<Resource>(r); //此时 forget 函数会获取 r 的所有权，但是并不会调用 Resource 的析构函数来释放堆内存
}

int main() {
    char val[sizeof(Resource)];
    get_resource(val);
    return 0;
}
```

### 安全数据结构

#### `Vec`

`Vec`是 BiShengC 语言提供的安全动态数组类型,数组元素的数据存储在堆上，它是一个泛型数据结构，接受一个类型参数 T 表示其内部存储的数据的类型，其使用示例如下：

```c
#include "vec.hbs"

safe void example(void) {
    Vec<int> vec = Vec<int>::new(); // 分配一个空的动态数组
    vec.push(1); // 向数组中插入元素
    vec.push(2); // 向数组中插入元素

    size_t len = vec.length();
    int elem = *vec.get(0); // elem is 1

    vec.set(0, 7); // 将索引为0处的值置为7
    elem = *vec.get(0); // elem is 7

    vec.shrink_to_fit();
    // vec作用域结束时自动调用析构函数释放堆内存空间,无需手动释放
}
```

索引：
`Vec`目前不支持直接使用索引进行访问，但其提供了`set`和`get`等方法,可以传入想要访问的元素的索引，通过函数调用的方式进行访问。

容量及重新分配：
`Vec`的容量是为将来添加到`Vec`中的任何元素预先分配的内存空间大小，不要将其与`Vec`的长度向混淆，`Vec`的长度表示的是当前`Vec`内实际存储的元素的数量。
如果`Vec`的长度超过其容量，则容量会自动增长，且其元素也需要重新分配(这由Vec内部实现)。

注意：在使用`Vec<T>`时，需要保证 T 是 copy 语义的类型或 owned struct 类型，否则会编译期报错，因为对于其它类型，编译器无法知道应该如何清理内存。

`Vec`提供的对外接口及相应的使用用例如下：

|对外接口|接口功能|代码示例|
|---|---|---|
|`safe size_t Vec<T>::capacity(const Vec<T>* borrow this)`|返回数组的容量|size_t cap = vec.capacity();|
|`safe void Vec<T>::clear(Vec<T>* borrow this)`|清空数组的所有元素|vec.clear();|
|`safe const T* borrow Vec<T>::get(const Vec<T>* borrow this, size_t index)`|获取数组中下标为index的元素的不可变借用(**要做边界检查**)|const int* borrow elem = vec.get(2);|
|`safe T* borrow Vec<T>::get_mut(Vec<T>* borrow this, size_t index)`|获取数组中下标为index的元素的可变借用(**要做边界检查**)|int* borrow elem = vec.get_mut(2);|
|`safe _Bool Vec<T>::is_empty(const Vec<T>* borrow this)`|判断数组是否为空|_Bool flag = vec.is_empty();|
|`safe size_t Vec<T>::length(const Vec<T>* borrow this)`|返回数组的长度|size_t len = vec.length();|
|`safe Vec<T> Vec<T>::new(void)`|创建一个空的数组|Vec<int> vec = Vec<int>::new();|
|`safe T Vec<T>::pop(Vec<T>* borrow this)`|弹出数组中最后一个元素(**要做边界检查**)|int last = vec.pop();|
|`safe void Vec<T>::push(Vec<T>* borrow this, T value)`|向数组的尾部插入一个值为value的元素|vec.push(2);|
|`safe T Vec<T>::remove(Vec<T>* borrow this, size_t index)`|从数组中移除下标为index的元素(**要做边界检查**)|int m = vec.remove(3);|
|`safe void Vec<T>::set(Vec<T>* borrow this, size_t index, T value)`|将数组中下标为index的元素置为value(**要做边界检查**)|vec.set(3, 5);|
|`safe void Vec<T>::shrink_to_fit(Vec<T>* borrow this)`|调整数组占用的内存空间,将容量缩减到数组的长度|vec.shrink_to_fit();|
|`safe Vec<T> Vec<T>::with_capacity(size_t cap)`|创建一个容量为cap的空数组|Vec<int> vec = Vec<int>::with_capacity(120);|

注：`Vec`提供的安全 API 内部实现了严格的边界访问检查逻辑，确保在使用这些 API 时不会出现越界访问的问题。当发生越界访问时，程序打印当前的函数调用栈，并终止执行。

#### `String`

`String`是 BiShengC 语言提供的 C 风格的安全字符串类型，用于安全地管理分配在堆上的字符串。它拥有字符串内容的所有权，字符串的内容存储在堆分配的缓冲区中。其使用示例如下：

```c
String hello = String::from("Hello, world!");

hello.push('w');
hello.set(0, 'k');

String world = String::from("hello bishengc");
hello.equals(&const world);

String new_s = world.slice(1, 4);
```

内部表示：
`String`内部由三个部分组成：指向某些字节的指针、长度和容量。该指针指向`String`用于存储其数据的内部缓冲区，长度是当前存储在缓冲区中的字节数，容量是当前缓冲区的大小（以字节为单位）。因此，长度会始终小于或等于容量。存储字节的缓冲区始终分配在堆上。

`String`提供的对外接口及相应的使用用例如下：

|对外接口|接口功能|代码示例|
|---|---|---|
|`safe char* borrow String::as_mut_str(String* borrow this)`|返回对字符串的可变借用|char* borrow str = s.as_mut_str();|
|`safe const char* borrow String::as_str(const String* borrow this)`|返回对字符串的不可变借用|const char* borrow str = s.as_str();|
|`safe char String::at(const String* borrow this, size_t index)`|返回字符串的下标为index处的值（**要做边界检查**）|char c = s.at(2);|
|`safe size_t String::capacity(const String* borrow this)`|返回字符串的容量|size_t cap = s.capacity();|
|`safe _Bool String::equals(const String* borrow this, const String* borrow other);`|比较两个字符串是否相等|_Bool flag = str1.equals(str2);|
|`safe size_t String::find(const String* borrow this, char c)`|查找字符串中是否有字符c，返回第一次找到时的下标，如果没有找到，则返回bsc_string_no_pos|size_t pos = s.find('A');|
|`unsafe String String::from(const char* str)`|根据字符串字面量创建字符串|String s = String::from("hello");|
|`safe const T* borrow String::get(const String* borrow this, size_t index)`|获取字符串中下标为index的元素的不可变借用(**要做边界检查**)|const char* borrow elem = s.get(2);|
|`safe T* borrow String::get_mut(String* borrow this, size_t index)`|获取字符串中下标为index的元素的可变借用(**要做边界检查**)|char* borrow elem = s.get_mut(2);|
|`safe _Bool String::is_empty(const String* borrow this)`|判断字符串是否为空|_Bool flag = s.is_empty();|
|`safe size_t String::length(const String* borrow this)`|返回字符串的长度|size_t len = s.length();|
|`safe String String::new(void)`|创建一个空的字符串|String s = String::new();|
|`safe void String::push(String* borrow this, char value)`|向字符串的尾部插入一个值为value的元素|s.push('h');|
|`safe void String::set(String* borrow this, size_t index, char value)`|将字符串中下标为index的元素置为value(**要做边界检查**)|s.set(3, '5');|
|`safe void String::shrink_to_fit(String* borrow this)`|调整字符串占用的内存空间,将容量缩减到字符串的长度|s.shrink_to_fit();|
|`safe String String::slice(const String* borrow this, size_t start, size_t length);`|字符串切片，如果 start 大于字符串的长度，则会触发越界；对于 length，如果start + length 大于字符串的长度，则字符串切片只会取到字符串的结尾处|String new_string = s.slice(0, 5);|
|`safe String String::with_capacity(size_t cap)`|创建一个容量为cap的空字符串|String s = String::with_capacity(20);|

注：`bsc_string_no_pos`实际上是一个很大的 size_t 类型的值，即 SIZE_MAX。


#### LinkedList

##### 概述：

LinkedList是由双向链表来实现的，支持前后两种移动方向。

注意：在使用`LinkedList<T>`时，需要保证 T 是 copy 语义的类型或 owned struct 类型，否则会编译期报错，因为对于其它类型，编译器无法知道应该如何清理内存。

##### 头文件:

```c
#include "list.hbs"
```

##### API:

| 对外接口                                             | 接口功能                                                     | 代码示例                                                     |
| ---------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| LinkedList<T> LinkedList<T>::new()                   | 创建一个链表对象。                                           | #include "list.hbs"<br />// 新增int类型链表对象<br />LinkedList<int> list = LinkedList<int>::new(); |
| void LinkedList<T>::push_back(T el)                  | 向链表尾端插入一个数据。                                     | list.push_back(5); // 向链表尾插入数据5                      |
| void LinkedList<T>::push_front(T el)                 | 向链表表头插入一个数据。                                     | list.push_front(6); // 向链表头插入数据6                     |
| size_t LinkedList<T>::length()                       | 返回链表中已有数据个数。                                     | assert(2 == list.length());                                  |
| _Bool LinkedList<T>::is_empty()                      | 判断表是否为空表。                                           | list.push_back(4); <br />assert(0 == list.is_empty())        |
| T LinkedList<T>::pop_back()                          | 返回表尾数据，并将该数据从链表中删除。表不可以为空表。       | assert(5 == list.pop_back());                                |
| T LinkedList<T>::pop_front()                         | 返回表头数据，并将该数据从链表中删除。表不可以为空表。       | assert(6 == list.pop_front());                               |
| void LinkedList<T>::remove(T el)                     | 删除链表中所有指定数据。                                     | list.push_back(4);<br />list.remove(4); // 删除链表中所有值为4的元素 |
| void LinkedList<T>::clear()                          | 删除链表中所有数据。                                         | list.clear();                                                |
| T LinkedList<T>::front()                             | 返回表头数据，表不可以为空表。                               | list.push_front(3);<br />assert(3 == list.front())           |
| T LinkedList<T>::back()                              | 返回表尾数据，表不可以为空表。                               | list.push_back(3); <br />assert(3 == list.back())            |
| _Bool LinkedList<T>::contains(T el)                  | 检查表是否包含指定数据。                                     | list.push_back(6); <br />assert(1 == list.contains(6))       |
| LinkedList<T> LinkedList<T>::split_off(size_t index) | 在索引处将链表拆分为两个链表，<br />索引值不能大于链表中数据个数，<br />新链表包含索引值以及往后的数据。<br />若索引值为0，则旧链表将为空表，<br />若索引值等于表数据个数，则新链表将为空。 | LinkedList<int> l = LinkedList<int>::new();<br />l.push_back(5);<br />l.push_back(6);<br />l.push_front(4);<br />l.push_front(3);<br />LinkedList<int> j = l.split_off(2);<br />// 链表被拆为l和j两个表<br />assert(2 == l.length());      // 3 4<br />assert(2 == j.length());      // 5 6 |

#### `Option`

`Option`是 BiShengC 语言提供的用于处理可选值的一个安全数据结构，用来表示一个值可能存在或不存在这两种情况。
它是一个泛型数据结构，具有一个泛型参数`T`，用于表示其存储的可选值的类型。使用`Option`可以安全地处理一些函数的返回值，避免使用空指针等数据结构来表示一个值不存在的情况。
`Option`有两种状态，即`Some`和`None`，`Some`状态中会包含所需要的类型的值，而`None`状态中没有存储相应的值。
它的一个使用示例如下：

```c
#include "option.hbs" // Option类型声明在该头文件中，使用时需包含该头文件

Option<size_t> string_find(String str) {
    size_t pos = str.find('k');
    if (pos == bsc_string_no_pos) {
        return Option<size_t>::None(); // 如果没有找到k，则返回None
    } else {
        return Option<size_t>::Some(pos); // 如果找到了k，则返回Some，且Some中包含相应的值pos
    }
}

void use_option() {
    size_t pos = -1;
    String s = String::from("hello");
    Option<size_t> res = string_find(s);
    if (res.is_some()) { // 判断res是Some还是None
        pos = option_unwrap(res); // 对于Some，则调用option_unwrap获取其中的值
    } else {
        return; // 对于None，则不做处理
    }
}
```

这个例子中首先定义了一个函数`string_find`，对`String`的`find`方法进行了封装，用于处理找到字符k和没有找到字符k的情况。接下来在使用处，可以使用`is_some`方法处理返回的`Option<size_t>`类型的值，从而获取里面的数据或者不做处理。这种写法可以安全地处理一些函数的返回值，提高程序的安全性。

`Option`是一个owned struct类型的数据结构，因此其自带析构函数，可以安全地释放其所占用的内存空间，无需使用者进行手动内存释放。

注意：在使用`Option<T>`时，需要保证 T 是 copy 语义的类型或 owned struct 类型，否则会编译期报错，因为对于其它类型，编译器无法知道应该如何清理内存。

`Option`提供的对外接口及相应的使用用例如下：

|对外接口|接口功能|代码示例|
|---|---|---|
|`safe _Bool Option<T>::is_none(const Option<T>* borrow this)`|判断`Option`是否为`None`，若是则返回1，否则返回0|_Bool flag = option.is_none();|
|`safe _Bool Option<T>::is_some(const Option<T>* borrow this)`|判断`Option`是否为`Some`，若是则返回1，否则返回0|_Bool falg = option.is_some();|
|`safe Option<T> Option<T>::Some(T t)`|创建一个状态为`Some`的`Option`值，其中包含的`T`类型的结果的值为`t`|Option<size_t> option = Option<size_t>::Some(3);|
|`safe Option<T> Option<T>::None(void)`|创建一个状态为`None`的`Option`值，其中不包含`T`的类型的结果值|Option<size_t> option = Option<size_t>::None();|
|`safe T option_unwrap<T>(Option<T> option)`|展开option，从中取出存储的T类型的值，对于`Some`可以成功取出`T`类型的值，对于`None`则会导致运行时终止|size_t index = option_unwrap(option);|

注：`option_unwrap`函数并非`Option`类型的成员方法，且其再展开`None`时会运行时终止，因此建议在调用该函数前使用`is_some`或`is_none`对`Option`的状态先进行判断。

#### `HashMap`

`HashMap`是 BiShengC 语言提供的安全哈希表类型，哈希表的键和值都存储在堆上，它是一个泛型数据结构，具有三个泛型参数`K`、`V`和`S`。
其中`K`代表的是键的类型，`V`代表的是值的类型，而`S`代表的是该`HashMap`所使用的哈希函数。

我们可以用各种类型来作为键的类型，包含除float和double以外的各种基本类型，以及自定义的数据类型。
在将一个类型作为键的类型时，该类型必须实现了`hash`和`equals`这两个方法。BiShengC 已经为基本类型提供了这两个方法，无需使用者再次手动实现。

注意：在使用`HashMap<K, V>`时，需要保证 K 和 V 是 copy 语义的类型或 owned struct 类型，否则会编译期报错，因为对于其它类型，编译器无法知道应该如何清理内存。

对于哈希函数，BiShengC 提供了一个`SipHasher13`作为默认的哈希函数。该类型有两个方法用于创建其实例：

|对外接口|接口功能|代码示例|
|---|---|---|
|`SipHasher13 SipHasher13::new()`|创建默认的`SipHasher13`|SipHasher13 sh = SipHasher13::new();|
|`SipHasher13 SipHasher13::new_with_keys(uint64_t key0, uint64_t key1)`|使用`key0`和`key1`创建`SipHasher13`，BiShengC 还提供了`RandomState`类型，用于创建随机的`key0`和`key1`值|RandomState rs = RandomState::new();<br/>SipHasher13 sh = SipHasher13::new_with_keys(rs.k0, rs.k1);|

`HashMap`的一个使用实例如下：

```c
#include "hash_map.hbs" // HashMap类型声明在该头文件中，使用时需包含该头文件

// 使用HashMap来统计一个数组中各个值出现的次数
void hash_map_example(Vec<int> vec) {
    HashMap<int, int, SipHasher13> map = HashMap<int, int, SipHasher13>::with_hasher(SipHasher13::new()); // 创建HashMap

    for (size_t i = 0; i < vec.length(); i++) {
        const int* borrow cur = vec.get(i);
        if (map.contains_key(cur)) { // 判断map中是否已经有cur
            int* borrow v = map.get_mut(cur); // 获取键对应的值的可变借用
            *v = *v + 1; // 更新相应的值
        } else {
            int k = *cur;
            map.insert(k, 1); // 向map中插入键值对
        }
    }

    _Bool empty_flag = map.is_empty(); // 判断map是否为空
    int x = 3;
    _Bool key_flag = map.contains_key(&const x); // 判断map是否有键3
    Option<int> removed = map.remove(&const x);
    if (removed.is_some()) {
        int v = option_unwrap(removed);
    }
    map.clear(); // 清空map的所有元素
}
```

`HashMap`提供的对外接口及相应的使用用例如下：

|对外接口|接口功能|代码示例|
|---|---|---|
|`safe size_t HashMap<K, V, S>::capacity(const HashMap<K, V, S>* borrow this)`|返回哈希表的容量|size_t cap = map.capacity();|
|`safe void HashMap<K, V, S>::clear(HashMap<K, V, S>* borrow this)`|清空哈希表的所有键值对，但表的容量保持不变|map.clear();|
|`safe _Bool HashMap<K, V, S>::contains_key(const HashMap<K, V, S>* borrow this, const K* borrow k)`|判断哈希表是否存在值为\*k的键|int x = 1;<br/>_Bool flag = map.contains_key(&const x);|
|`safe Option<V* borrow> HashMap<K, V, S>::get_mut(HashMap<K, V, S>* borrow this, const K* borrow k)`|获取值为\*k的键对应的值的可变借用，若表中不存在键\*k，则返回None|int x = 1;<br/>int* borrow v = map.get_mut(&const x);|
|`safe void HashMap<K, V, S>::reserve(HashMap<K, V, S>* borrow this, size_t additional)`|调整哈希表的容量，使其调整后在不扩容的情况下能至少再存入additional个元素（一般来说，该方法无需手动调用，在调用insert时会被隐式调用一次）|map.reserve(1);|
|`safe Option<V> HashMap<K, V, S>::insert(HashMap<K, V, S>* borrow this, K k, V v)`|向哈希表中插入键为k、值为v的键值对|map.insert(1, 2);|
|`safe _Bool HashMap<K, V, S>::is_empty(const HashMap<K, V, S>* borrow this)`|判断哈希表是否为空|_Bool empty map.is_empty();|
|`safe size_t HashMap<K, V, S>::length(const HashMap<K, V, S>* borrow this)`|返回哈希表中存储的键值对的数量|size_t len = map.length();|
|`safe Option<V> HashMap<K, V, S>::remove(HashMap<K, V, S>* borrow this, const K* borrow k)`|从哈希表中移除键为\*k的键值对，并返回对应的值，如果哈希表不存在键\*k，则返回None|int x = 3;<br/>Option<int> removed = map.remove(&const x);<br/>if (removed.is_some()) { int y = option_unwrap(removed); }|
|`safe HashMap<K, V, S> HashMap<K, V, S>::with_capacity_and_hasher(size_t cap, S hash_builder)`|创建初始容量为cap、哈希函数为hash_builder的哈希表|HashMap<int, int, SipHasher13> map = HashMap<int, int, SipHasher13>::new_with_cap_and_hasher(3, SipHasher13::new());|
|`safe HashMap<K, V, S> HashMap<K, V, S>::with_hasher(S hash_builder)`|创建初始容量为0，哈希函数为hash_builder的哈希表|HashMap<int, int, SipHasher13> map = HashMap<int, int, SipHasher13>::new_with_hasher(SipHasher13::new());|

### Rc
#### 概述
BiShengC 的所有权机制要求一个值只能有一个所有者，然而，我们考虑以下场景：
1. 在图数据结构中，多个边可能指向相同的节点，这个节点为所有指向它的边所共有，该节点直到没有边指向它时，才能被释放清理
2. 当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候，这部分内存直到最后一个部分使用结束时，才能被释放清理

为解决此类问题，需要允许一个值在同一时刻拥有多个所有者，因此 BSC **在标准库中提供 `Rc<T>` 类型来实现所有权的共享，它是一种智能指针，指向被共享的数据**。为提高 Rc 的安全性，BSC 同时提供了 `Weak<T>` 来避免循环引用造成的内存泄漏问题，也提供了 `Cell<T>` 和 `RefCell<T>` 与 Rc 组合使用来实现 Rc 指向数据的可变性。

#### 使用 `Rc<T>` 共享数据
Rc 是引用计数（reference counting）的缩写，通过记录数据被引用的次数，来确定数据是否正在被使用，引用的数量就相当于所有者的数量。**如果引用计数变为 0，就意味着被引用数据可以被清理，此时 Rc 会自动调用数据的析构函数，避免内存泄漏。**

注意：在使用 `Rc<T>` 时，需要保证 T 是 copy 语义的类型或 owned struct 类型，否则会编译期报错，因为对于其它类型，编译器无法知道应该如何清理内存。

`Rc<T>` 的使用方法是：
1. 调用 new 方法来创建 Rc，该方法会分配堆内存，并将所要引用的数据存储在堆上
2. 调用 clone 方法可以从已有 Rc 得到另一个 Rc，该方法不执行深拷贝，仅仅创建另一个指向被引用数据的指针
3. 调用 deref 方法可以获取 Rc 所指向数据的不可变借用

我们通过以下的例子来学习 Rc 的使用：
假如一个班上有若干学生，他们共享一份成绩单，这份成绩记录文件就是需要被共享的数据资源，现在我们读取该文件来获取 1 号学生和 2 号学生的成绩：
```C
#include "rc.hbs"

owned struct ScoreRecord {  //学生成绩记录文件
    FILE *fp;
    ~ScoreRecord(This this) {
        fclose(this.fp);
    }
};

owned struct Student {
    unsigned student_id;    //学生id
    Rc<ScoreRecord> scores; //假设学生成绩记录文件为所有学生所共有
};

// 打开文件
ScoreRecord ScoreRecord::open(String filename);
// 读取文件第 id 行内容
String ScoreRecord::read(const This *borrow this, unsigned id);

// 获取 id 号学生的成绩
String Student::get_score(const This *borrow this) {
    const ScoreRecord *borrow scores = this->scores.deref(); 
    return scores->read(this->id);
}

int main() {
    ScoreRecord scores = ScoreRecord::open(String::from("scores.txt"));

    // student1 和 student2 共同拥有成绩文件的所有权
    Rc<ScoreRecord> rc1 = Rc<ScoreRecord>::new(scores);
    Rc<ScoreRecord> rc2 = rc1.clone()；
    Student student1 = { .id = 1, .scores = rc1 };
    Student student2 = { .id = 2, .scores = rc2 };
    // 此时共享文件的引用计数为 2，因为它有 2 个所有者

    print("学生1的成绩为：" + student1.get_score());
    print("学生2的成绩为：" + student2.get_score());

    return 0;
}   // 共享文件被使用完毕，引用计数变为 0，此时 Rc 会自动调用 ～ScoreRecord 来关闭文件
```

#### 引用计数
让我们通过以下案例来观察 `Rc<T>` 在创建、克隆和走出作用域时引用计数的变化。
```C
int main() {
    Rc<int> rc1 = Rc<int>::new(5);
    printf("ref count after creating rc1 = %d\n", rc1.strong_ref_count());
    Rc<int> rc2 = rc1.clone();
    printf("ref count after creating rc2 = %d\n", rc1.strong_ref_count());
    {
        Rc<int> rc3 = rc1.clone();
        printf("ref count after creating rc3 = %d\n", rc1.strong_ref_count());
    }
    printf("ref count after rc3 goes out of scope = %d\n", rc1.strong_ref_count());
    return 0;
}
```
这段代码会打印出：
```
ref count after creating rc1 = 1
ref count after creating rc2 = 2
ref count after creating rc3 = 3
ref count after rc3 goes out of scope = 2
```
我们能够看到 rc1 的初始引用计数为 1，随着每次调用 clone，计数会增加 1。当 rc3 离开作用域时，计数减 1。不必像调用 clone 增加引用计数那样调用一个函数来减少计数，因为 `Rc<T>` 析构函数的实现可以保证当一个 Rc 离开作用域时自动减少引用计数。

从这个例子我们所不能看到的是，在 ref_count 函数的结尾处，随着 rc1、rc2 离开作用域，计数会降为 0，其指向的数据也将被清理，这一清理操作也是通过 `Rc<T>` 的析构函数来自动实现的。

#### `Cell<T>`/`RefCell<T>` 与内部可变性

通过 deref 方法可以获取 Rc 所指向数据的不可变借用，这允许在程序的多个部分之间只读地共享数据。如果 `Rc<T>` 也允许多个可变借用，会违反 BSC 的借用规则：不能同时存在对同一数据的多个可变借用。但是在实际应用场景，修改数据是不可避免的。在这一部分，我们将讨论内部可变性模式和 Cell/RefCell 类型，它们**可以与 Rc 结合使用来修改 Rc 所指向的数据**。

BSC 编译器会在编译时对借用规则进行严格的检查，它可能会拒绝一个正确的程序，这往往会让用户痛苦不堪。因此在标准库中提供了 `Cell<T>` 和 `RefCell<T>` 来实现内部可变性：在拥有不可变借用的同时修改目标数据！对于正常的代码实现来说，这个是不可能做到的（要么一个可变借用，要么多个不可变借用）。

##### `Cell<T>`
`Cell<T>` 用于获取它内部包裹的值的拷贝或直接修改内部值，适用于 Copy 语义的类型，例如 int、float 等基本数据类型或 struct 类型。
```C
void cell_example() {
    Cell<int> c = Cell<int>::new(5);
    printf("Value in cell is: %d\n", c.get()); // get 方法可以获取 cell 内部包裹的值的拷贝
    c.set(10);   // set 方法可以直接修改 cell 内部包裹的值
    printf("Value in cell is: %d\n", c.get());
}
```
##### `RefCell<T>`
`RefCell<T>` 用于获取它内部包裹的值的可变或不可变借用，它实际上**并没有解决可变借用和不可变借用可以共存的问题，只是将报错从编译期推迟到运行时 abort**。

通过使用 `RefCell<T>` 的 borrow_mut 和 borrow_immut 方法，来尝试在运行时获取借用，如果借用成功，返回 `RefMut<T>` 或 `RefImmut<T>` 类型的值，否则会导致运行时 abort。规则是：
1. borrow_mut 方法用于获取 `RefMut<T>`，如果当前作用域内存在**任何其它借用**，则借用失败
2. borrow_immut 方法用于获取 `RefImmut<T>`，如果当前作用域存在**任何其它可变借用**，则借用失败

`RefMut<T>` 和 `RefImmut<T>` 是 `RefCell<T>` 的辅助数据结构，它们的 deref 方法可以分别获取 RefCell 内部值的可变和不可变借用。
```C
void refcell_example() {
    RefCell<int> c = RefCell<int>::new(5);

    // 通过 RefCell 的 borrow_mut 方法获得 RefMut：
    RefMut<int> ref_mut_c1 = c.borrow_mut();

    // 通过 RefMut 的 deref 方法获得 RefCell 内部值的可变借用：
    int* borrow mut_p1 = ref_mut_c.deref();

    // 通过可变借用修改内部值：
    *mut_p1 = 10;  

    // 再次尝试获取可变借用
    RefMut<int> ref_mut_c2 = c.borrow_mut(); //运行时abort，因为同时存在两个可变借用
}
```
#### Rc 和 RefCell 相结合来实现共享数据的修改
上面的读取学生成绩的案例我们只对数据进行了读操作，有了 RefCell，我们可以实现对共享数据的修改，以下例子实现了对成绩数据的读取和更新：
```C
#include "rc.hbs"
#include "cell.hbs"

owned struct ScoreRecord {  //学生成绩记录文件
    FILE *fp;
    ~ScoreRecord(This this) {
        fclose(this.fp);
    }
};

owned struct Student {
    unsigned student_id;
    Rc<RefCell<ScoreRecord>> scores; //将需要被修改的共享数据用 RefCell 进行包装
};

// 打开文件
ScoreRecord ScoreRecord::open(String filename);
// 读取文件第 id 行内容
String ScoreRecord::read(const This *borrow this, unsigned id);
// 更新文件第 id 行内容
void ScoreRecord::update(This *borrow this, unsigned id, String new);

// 获取 id 号学生的成绩
String Student::get_score(const This *borrow this) {
    // RefCell 的 borrow_immut 方法获取不可变借用
    RefImmut<ScoreRecord> ref_scores = this->scores.deref()->borrow_immut(); 
    const ScoreRecord *borrow scores = ref_scores.deref();
    return scores->read(this->id);
}

// 更新 id 号学生的成绩
String Student::update_score(const This *borrow this, String new_score) {
    // RefCell 的 borrow_mut 方法获取可变借用
    RefMut<ScoreRecord> ref_scores = this->scores.deref()->borrow_mut(); 
    ScoreRecord *borrow scores = ref_scores.deref();
    return scores->update(this->id, new_score);
}

int main() {
    ScoreRecord scores = ScoreRecord::open(String::from("scores.txt"));

    Rc<RefCell<ScoreRecord>> rc1 = Rc<RefCell<ScoreRecord>>::new(RefCell<ScoreRecord>::new(scores));
    Rc<RefCell<ScoreRecord>> rc2 = rc1.clone()；
    Student student1 = { .id = 1, .scores = rc1 };
    Student student2 = { .id = 2, .scores = rc2 };

    student1.update_score(String::from("100"));
    student2.update_score(String::from("99"));

    print("学生1的成绩为：" + student1.get_score());
    print("学生2的成绩为：" + student2.get_score());

    return 0;
}
```

#### `Weak<T>` 解决循环引用问题
尽管 BSC 有着完善的内存安全保障机制，但是不代表不会产生内存泄漏。一个典型的例子就是同时使用 `Rc<T>` 和  `RefCell<T>` 创建循环引用，由于引用计数无法被归零，因此 `Rc<T>` 指向的数据也就不会被释放清理。

##### 制造循环引用
```C
#include "rc.hbs"
#include "cell.hbs"

owned struct B;

owned struct A {
public:
    int value;
    RefCell<Rc<B>> c;
    ~A(A this) {
        printf("A is destructed, value = %d\n", this.value);
    }
};

owned struct B {
public:
    int value;
    RefCell<Rc<A>> d;
    ~B(B this) {
        printf("B is destructed, value = %d\n", this.value);
    }
};

int main() {
    A a = { .value = 5 };
    Rc<A> ap = Rc<A>::new(a);      //ap 拥有 a

    B b = { .value = 10 };
    RefMut<Rc<A>> rm_b = b.d.borrow_mut();
    *(rm_b.deref()) = ap.clone();  //通过 ap 的克隆，此处 b.d 拥有了 a
    Rc<B> bp = Rc<B>::new(b);      //bp 拥有 b

    RefMut<Rc<B>> rm_a = ap.deref()->c.borrow_mut();
    *(rm_a.deref()) = bp.clone();  //通过 bp 的克隆，此处 a.c 拥有了 b

    printf("ref count of a : %d\n", ap.strong_ref_count());
    printf("ref count of b : %d\n", bp.strong_ref_count());

    return 0;
}
```
这段代码会打印出：
```
ref count of a : 2
ref count of b : 2
```
在函数结束前，a 和 b 的引用计数都为 2，其中 a 为 ap 和 b.d 所共有，b 为 bp 和 a.c 所共有。

在函数结束处：
1. 对 a 来说，ap 走出作用域后 a 的引用计数由 2 变为 1，只有当 b.d 析构会使 a 的引用计数减为 0 从而触发 a 的析构
2. 对 b 来说，bp 走出作用域后 b 的引用计数由 2 变为 1，只有当 a.c 析构会使 b 的引用计数减为 0 从而触发 b 的析构

a 的析构需要 b 先被析构，而 b 的析构需要 a 先被析构，结果就是 a 和 b 都没有被析构，内存泄漏了！

##### 使用 `Weak<T>` 解决循环引用
为解决这一问题，BSC 引入 `Weak<T>` 类型，与 Rc 持有所有权不同，Weak 不持有所有权，它仅仅保存一份指向数据的弱引用，**建立弱引用不会增加引用计数，它也无法阻止所引用的数据被清理掉**。

`Weak<T>` 的使用方法是：
1. 调用 new 方法，通过一个已有的 `Rc<T>` 创建 `Weak<T>`
2. 无法通过 `Weak<T>` 直接访问被引用数据，如果想要访问数据，需要将 Weak 升级为 Rc，这通过 Weak 的 upgrade 方法实现，该方法返回一个类型为 `Option<Rc<T>>` 的值，如果被引用数据已经被清理释放，则 Option 的值是 None，也就是说，Weak 本身不对被引用数据的存在性做任何担保。

##### 循环引用场景 1
我们以上一小节中 a 和 b 循环引用导致内存泄漏的例子来学习`Weak<T>`的使用：
```C
#include "rc.hbs"
#include "cell.hbs"

owned struct B;

owned struct A {
public:
    int value;
    RefCell<Rc<B>> c;     //A 通过 Rc 引用 B
    ~A(A this) {
        printf("A is destructed, value = %d\n", this.value);
    }
};

owned struct B {
public:
    int value;
    RefCell<Weak<A>> d;  //B 通过 Weak 引用 A
    ~B(B this) {
        printf("B is destructed, value = %d\n", this.value);
    }
};

int main() {
    A a = { .value = 5 };
    Rc<A> ap = Rc<A>::new(a);           //ap 拥有 a

    B b = { .value = 10 };
    RefMut<Weak<A>> rm_b = b.d.borrow_mut();
    *(rm_b.deref()) = Weak<A>::new(ap); //通过 ap 创建弱引用，此处 b.d 弱引用 a
    Rc<B> bp = Rc<B>::new(b);           //bp 拥有 b

    RefMut<Rc<B>> rm_a = ap.deref()->c.borrow_mut();
    *(rm_a.deref()) = bp.clone();       //通过 bp 的克隆，此处 a.c 拥有了 b

    printf("ref count of a : %d\n", ap.strong_ref_count());
    printf("ref count of b : %d\n", bp.strong_ref_count());

    return 0;
}
```
这段代码会打印出：
```
ref count of a : 1
ref count of b : 2
B is destructed, value = 10
A is destructed, value = 5
```
通过打印结果，我们看到 a 和 b 都被析构了，分析这段代码：
1. 在函数结束前，a 为 ap 所拥有，引用计数为 1，b 为 bp 和 a.c 所共有，引用计数为 2；
2. 在函数结束处，ap 走出作用域后 a 的引用计数由 1 变为 0，从而触发 a 的析构，因为 a.c 拥有 b，随着 a 的析构，b 的引用计数由 2 减为 1；随后 bp 走出作用域后 b 的引用计数由 1 变为 0，从而触发 b 的析构。

##### 循环引用场景 2
Weak 常常被应用于父子循环引用关系中，做法是：让父节点通过 Rc 来引用子节点，然后让子节点通过 Weak 来引用父节点。接下来我们构造一个简单的 tree，它有 1 个 root 节点和 2 个 leaf 节点：
```C
owned struct Node {
public:
    int value;
    RefCell<Weak<Node>> parent;      //子结点通过 Weak 引用父节点
    RefCell<Vec<Rc<Node>>> children; //父结点通过 Rc 引用子节点
	
    ~Node(Node this) {
        printf("node %d is destructed\n", this.value);
    }
};

void tree() {
    // 构造叶子节点
    Node temp_leaf1 = { .value = 5, .children = RefCell<Vec<Rc<Node>>>::new(Vec<Rc<Node>>::new()) };
    Node temp_leaf2 = { .value = 6, .children = RefCell<Vec<Rc<Node>>>::new(Vec<Rc<Node>>::new()) };
    Rc<Node> leaf1 = Rc<Node>::new(temp_leaf1);
    Rc<Node> leaf2 = Rc<Node>::new(temp_leaf2);

    printf("ref count of leaf1 after init : %d\n", leaf1.strong_ref_count());
    printf("ref count of leaf2 after init : %d\n", leaf2.strong_ref_count());

    // 构造父节点，并让父结点通过 Rc 引用子节点
    Node temp_root = { .value = 10, .children = RefCell<Vec<Rc<Node>>>::new(Vec<Rc<Node>>::new()) };
    RefMut<Vec<Rc<Node>>> rm_root_children = temp_root.children.borrow_mut();
    rm_root_children.deref()->push(leaf1.clone());
    rm_root_children.deref()->push(leaf2.clone());
    Rc<Node> root = Rc<Node>::new(temp_root);

    printf("ref count of root after init : %d\n", root.strong_ref_count());
    printf("ref count of leaf1 after root points to it : %d\n", leaf1.strong_ref_count());
    printf("ref count of leaf2 after root points to it : %d\n", leaf2.strong_ref_count());

    // 子结点通过 Weak 引用父节点
    RefMut<Weak<Node>> rm_leaf1_parent = leaf1.deref()->parent.borrow_mut();
    *(rm_leaf1_parent.deref()) = Weak<Node>::new(&const root);
    RefMut<Weak<Node>> rm_leaf2_parent = leaf2.deref()->parent.borrow_mut();
    *(rm_leaf2_parent.deref()) = Weak<Node>::new(&const root);

    printf("ref count of root after leaf1 and leaf2 weakly points to it : %d\n", root.strong_ref_count());
}
```
这段代码会打印出：
```
ref count of leaf1 after init : 1
ref count of leaf2 after init : 1
ref count of root after init : 1
ref count of leaf1 after root points to it : 2
ref count of leaf2 after root points to it : 2
ref count of root after leaf1 and leaf2 weakly points to it : 1
node 5 is destructed
node 6 is destructed
node 10 is destructed
```
通过打印结果可以看到所有的节点数据都被清理释放。

#### 相关 API
##### `Rc<T>` 对外接口
|对外接口|接口功能|代码示例|
|---|---|---|
|`safe Rc<T> Rc<T>::new(T data)`|构造一个 Rc，开辟堆内存存储 data|`Rc<int> rc = Rc<int>::new(5);`|
|`safe Rc<T> Rc<T>::clone(const This * borrow this)`|通过一个已有 Rc，克隆出另一个 Rc，会使引用计数加 1|`Rc<int> rc2 = rc.clone();`|
|`safe unsigned Rc<T>::strong_ref_count(const This * borrow this)`|获取强引用计数|`unsigned count = rc.strong_ref_count();`|
|`safe unsigned Rc<T>::weak_ref_count(const This * borrow this)`|获取弱引用计数|`unsigned count = rc.weak_ref_count();`|
|`safe const T * borrow Rc<T>::deref(const This * borrow this)`|获取 Rc 指向数据的不可变借用|`const int * borrow data = rc.deref();`|

##### `Weak<T>` 对外接口
|对外接口|接口功能|代码示例|
|---|---|---|
|`safe Weak<T> Weak<T>::new(const Rc<T> * borrow rc)`|通过一个已有 Rc，构造出一个 Weak|`Weak<int> w = Weak<int>::new(&const rc);`|
|`safe Weak<T> Weak<T>::clone(const This * borrow this)`|通过一个已有 Weak，克隆出另一个 Weak|`Weak<int> w2 = w.clone();`|
|`safe unsigned Weak<T>::strong_ref_count(const This * borrow this)`|获取强引用计数|`unsigned count = w.strong_ref_count();`|
|`safe unsigned Weak<T>::weak_ref_count(const This * borrow this)`|获取弱引用计数|`unsigned count = w.weak_ref_count();`|
|`safe Option<Rc<T>> Weak<T>::upgrade(const This * borrow this)`|将 Weak 转化为对应的 Rc，转化失败时返回 None|`Option<Rc<T>> rc = w.upgrade();`|

##### `Cell<T>` 对外接口
|对外接口|接口功能|代码示例|
|---|---|---|
|`safe Cell<T> Cell<T>::new(T value)`|用所给 value 构造 Cell|`Cell<int> c = Cell<int>::new(5);`|
|`safe T Cell<T>::get(const This * borrow this)`|获得 Cell 内部值的拷贝|`int a = c.get();`|
|`safe void Cell<T>::set(const This * borrow this, T val)`|将 Cell 内部值替换为 val|`c.set(10);`|

##### `RefCell<T>` 对外接口
|对外接口|接口功能|代码示例|
|---|---|---|
|`safe RefCell<T> RefCell<T>::new(T value)`|用所给 value 构造 RefCell|`RefCell<int> c = RefCell<int>::new(5);`|
|`safe RefImmut<T> RefCell<T>::borrow_immut(const This * borrow this)`|获得 RefCell 内部值的RefImmut<T>，失败会导致 abort|`RefImmut<int> ref = c.borrow_immut();`|
|`safe Option<RefImmut<T>> RefCell<T>::try_borrow_immut(const This * borrow this)`|获得 RefCell 内部值的 RefImmut<T>，失败会返回 None|`Option<RefImmut<int>> ref = c.try_borrow_immut();`|
|`safe RefMut<T> RefCell<T>::borrow_mut(const This * borrow this)`|获得 RefCell 内部值的 RefMut<T>，失败会导致 abort|`RefMut<int> ref = c.borrow_mut();`|
|`safe Option<RefMut<T>> RefCell<T>::try_borrow_mut(const This * borrow this)`|获得 RefCell 内部值的 RefMut<T>，失败会返回 None|`Option<RefMut<int>> ref = c.try_borrow_mut();`|

##### `RefImmut<T>/RefMut<T>` 对外接口
|对外接口|接口功能|代码示例|
|---|---|---|
|`safe const T * borrow RefImmut<T>::deref(const This * borrow this)`|获取 RefCell 内部值的不可变借用|`const int * borrow p = immut_ref.deref();`|
|`safe T * borrow RefMut<T>::deref(This * borrow this)`|获取 RefCell 内部值的可变借用|`int * borrow p = mut_ref.deref();`|

### 协程调度器

#### Scheduler

##### 概述：

`Scheduler` 是 BiShengC 语言提供的负责协调和管理协程的数据结构，它使用了协程机制来支持高并发的异步编程，主要作用是将可执行的任务分配给可用线程来执行，以最大程度地利用计算机资源。其使用示例如下：

```c
#include <unistd.h>
#include "scheduler.hbs" // 引入头文件

atomic_int g_student_num = 10;

struct Student {
    char * name;
    int age;
    int score;
};

struct Student nameList[] =
{
    {"Mary", 12, 90},
    {"John", 13, 95},
    {"Michael", 12, 93},
    {"Emily", 11, 92},
    {"James", 12, 86},
    {"Emma", 12, 95},
    {"William", 11, 90},
    {"Jessica", 13, 80},
    {"Lily", 12, 92},
    {"Sarah", 12, 88}
};

async void readName(int i) {
    // 模拟 IO 操作，读取学生名单
    printf("name: %s, age: %d, score: %d\n", nameList[i].name, nameList[i].age, nameList[i].score);

    atomic_fetch_sub(&g_student_num, 1);
    // 任务完成，销毁调度器
    if (atomic_load(&g_student_num) == 0) {
        struct Scheduler::destroy();
    }
}

int main() {
    // 初始化，创建 4 个线程
    struct Scheduler::init(4);
    for (int i = 0; i < g_student_num; i++) {
        // 将任务放入执行队列中
        struct Scheduler::spawn(readName(i));
    }
    // 执行调度器
    struct Scheduler::run();
    return 0;
}
```

输出结果如下：

```
name: Mary, age: 12, score: 90
name: Michael, age: 12, score: 93
name: Emily, age: 11, score: 92
name: James, age: 12, score: 86
name: Emma, age: 12, score: 95
name: William, age: 11, score: 90
name: Jessica, age: 13, score: 80
name: Lily, age: 12, score: 92
name: Sarah, age: 12, score: 88
name: John, age: 13, score: 95
```

调度器是一个用于管理和调度任务的工具，`init`方法是在创建调度器对象时调用的，主要用于初始化调度器的一些属性。`spawn` 方法用于创建一个异步任务，并将任务添加到任务队列中**等待执行**。`run` 方法是调度器的核心方法，用于**执行异步任务**。需要注意的一点是，只有当我们调用 `run` 方法时，调度器才会真正的执行任务。`destroy` 方法是在我们不再需要使用调度器时调用的，主要用于清理调度器的一些资源和释放占用的系统资源。

另外，从这个输出结果来看，输出顺序并不是按照数组本身的顺序，并且多次执行输出顺序也可能不同，所以这比较适用于不需要严格要求执行顺序的任务。

##### 头文件:

```c
#include "scheduler.hbs"
```

##### API:

| 对外接口                                                     | 接口功能                                                     | 代码示例                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `void struct Scheduler::init(unsigned int threadCount)`      | 用于初始化调度器，不可多次重复初始化，参数为用户需要创建的线程数 | struct Scheduler::init(4);                                   |
| `struct Task * struct Scheduler::spawn(trait Future<struct Void> * future)` | 创建异步任务，并将任务放入执行队列中等待执行（目前仅接受返回类型是void的任务）。 | async void  taskFunc(int i) { <br/>    while(i < 10000) { <br/>        i = (i * 2) + 3 ; <br/>    }<br/>    printf("result: %d\n", i);<br/>}<br>struct Scheduler::spawn(taskFunc(0)); |
| `void struct Scheduler::run()`                               | 执行通过 spawn 函数创建的异步任务                            | struct Scheduler::run();                                     |
| `void struct Scheduler::destroy()`                           | 销毁调度器，释放资源                                         | struct Scheduler::destroy();                                 |

具体数据结构介绍如下：

`struct Scheduler`：表示调度器，包括任务队列和线程池。通过 `struct Scheduler::init`方法创建并初始，但由于一个进程只能有一个 Scheduler，所以不能重复初始化。当然，也不允许未初始化就直接使用，在调用 `struct Scheduler::spawn` 或  `struct Scheduler::run` 方法前，必须调 `struct Scheduler::init`。如果不再需要调度器了，可以通过 `struct Scheduler::destroy` 方法进行销毁（如果不销毁，进程无法终止）。

`strcut Task`: 表示异步任务，包括任务的状态和执行上下文。通过 `struct Scheduler::spawn` 方法进行创建，创建完成后会将其放入执行队列，但不会立马执行。只有调用了 `struct Scheduler::run` 方法才会真正的执行队列中的任务。

另外，我们注意到 `struct Scheduler::spawn` 方法的入参是 `trait Future<struct Void> *` 类型（`trait Future` 的定义可参考无栈协程章节），所以我们除了可以传入返回类型是 `void` 的 async 函数调用，也可以传显式返回 `trait Futrue<struct Void> *`  类型的函数调用，具体使用如下：

```c
#include "scheduler.hbs"

atomic_int g_task_num = 10;

struct _Futurework {
    int a;
    int __future_state;
};

// 必须实现 poll 和 free 两个函数
struct PollResult<struct Void> struct _Futurework::poll(struct _Futurework *this) {
    switch (this->__future_state) {
      case 0:
        goto __L0;
    }
  __L0:
    ;
    printf("The %d-th calculation begins\n", this->a);
    while (this->a < 100000000)
        {
            this->a++;
        }

    atomic_fetch_sub(&g_task_num, 1);
    if (atomic_load(&g_task_num) == 0) {
        struct Scheduler::destroy();
    }

    this->__future_state = -1;
    struct Void __RES_RETURN = (struct Void){};
    return struct PollResult<struct Void>::completed(__RES_RETURN);
}

void struct _Futurework::free(struct _Futurework *this) {
    if (this != 0) {
        free((void *)this);
        this = (struct _Futurework *)(void *)0;
    }
}

impl trait Future<struct Void> for struct _Futurework;

trait Future<struct Void>* work(int a)     {
  struct _Futurework* ptr = malloc(sizeof(struct _Futurework));
  ptr->a = a;
  ptr->__future_state = 0;
  return ptr;
}

int main() {
    struct Scheduler::init(4);
    for (int i = 0; i < 10; i++) {
        struct Scheduler::spawn(work(i));
    }
    struct Scheduler::run();
    return 0;
}
```




------
