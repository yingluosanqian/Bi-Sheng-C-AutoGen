## 无栈协程

### 无栈协程简介

无栈协程与有栈协程调用栈由程序员显示分配的不同，协程的调用栈由运行时系统隐式管理的，协程本身不持有自己的调用栈，在切换协程时不需要保存和恢复整个调用栈，只保存协程执行状态。它是通过 `async/await` 关键字进行定义和调用。`async` 用来修饰异步函数，`await` 实现异步函数调用。

毕昇 C 的无栈协程目标是支持异步、高并发场景，例如 Web 服务器实现高并发网络通信、异步处理请求、 Web 应用程序的数据库连接池等。

### Future/PollResult标准库定义

#### Future/PollResult定义

**Future** 用于描述某个计算（或任务）尚未结束，用一个对象来代理这个未知的结果，这个计算（或任务）可以暂停和恢复。

Future 的执行是通过调用 poll 函数实现的。

**PollResult** 即 poll 函数返回值，用于描述计算（或任务）执行状态以及结果。

```c
struct PollResult<T> {
    _Bool isPending; //isCompleted
    T res;
};

T struct PollResult<T>::is_pending(struct PollResult<T>* this) { ... }
struct PollResult<T> struct PollResult<T>::pending() { ... }
_Bool struct PollResult<T>::is_completed(struct PollResult<T> *this, T *out) { ... }
struct PollResult<T> struct PollResult<T>::completed(T result) { ... }

trait Future<T> {
    struct PollResult<T> poll(This* this);
    void free(This* this);
};
```

#### Future/PollResult使用

协程的实现使用到 Future/PollResult 定义，其导入方式有系统默认导入和用户显式导入两种。

用户显式导入时需要引用头文件 `future.hbs`。文件安装在系统 /usr/include 默认搜索路径下（或者安装在指定目录）在编译时使用 -I 编译选项指定路径。

```c
#include  "future.hbs"
```

### 语法规则

1. 无栈协程只允许在毕昇 C 编译单元使用

2. 如果函数中使用了 `await` 关键字，那么这个函数必须用 `async` 修饰。`async` 函数内可以有 0,1...n 个 `await` 表达式

```c
async int TimeOut(int t) {
    return t;
}

async int getData1() {
    int t = await TimeOut(1000);
    return t;
}

async int getData2() {
    await getData1();
    await TimeOut(1000);
    await TimeOut(2000);
    return 0;
}
```

3. `async` 函数声明和实现可以分开

```c
#include "string.h"

async int ReadBuffer(char *str);

async int GetBufferSize() {
    char* Content;
    char ContentCopy[12] = "hello,word!";
    Content = ContentCopy;
    int size = await ReadBuffer(Content);
    return size;
}

async int ReadBuffer(char *str) {
    char *cstr = "hello,word!";
    if (strcmp(str, cstr) == 0)
      return sizeof(str);
    else return 0;
}
```

4. `async` 函数支持递归调用

```c
async int f(int n) {
    if (n == 0 || n == 1)
        return 1;
    int tmp = await f(n-1);
    return n*tmp;
}
```

5. `async` 关键字可以修饰成员函数

```c
async void int::g(int* this);

async int int::f() {
    int i = 1;
    await int::g(&i);
    await i.g();
    return 0;
}

async void int::g(int* this) {
    trait Future<int>* a = read(1);
    await a;
}
```

6. `async` 函数中可以出现多个不同或相同 `await` 表达式

```c
async void client1() {
    // client1 send message...
}

async void client2() {
    // client2 send message...
}

async int Server(int start) {
    // server receive message
    await client1();
    if (start < 20)
        await client2();
    return start;
}
```

7. `async` 函数不支持变量数组，即数组中含有变量

```c
async int f() {
    int *VarArray1[n]; // expected-error {{async function does not support VariableArrayType}}
    int VarArray2[3][2][n]; // expected-error {{async function does not support VariableArrayType}}
    int *VarArrayPtr[n][2][n][5]; // expected-error {{async function does not support VariableArrayType}}
    int Array[3]; // support
    int MultiArray[2][3][4][5]; // support
    return 0;
}
```

8. `await` 表达式不能出现在 if/while/for/do-while 等判断条件中

```c
async int read(int n) {
    // read data...
    return n;
}

async int getData() {
    int res = 0;
    if (await read(1)) { // expected-error {{await expression is not allowed to appear in condition statement of if statement}}
        res = await read(1);
    }

    if (res == 2) { // support
        res = await read(1);
    }
    return res;
}
```

9. `await` 表达式不能和“有副作用”的表达式（例如函数）并存

```c
async int read(int n) {
    // read data...
    return n;
}

int test(int a, int b) {
    return 42;
}

async int f() {
    test(await read(2), await read(2)); // expected-error {{await expression is not allowed to appear in function parameters}}
    test(t(), await read(2)); // expected-error {{await expression is not allowed to appear in function parameters}}
    test(3, await read(2)); // support
    return 0;
}
```

10. `await` 表达式不能出现在复合表达式中，例如：表达式中含有 +、-、*、/、%、&、|、>>、<< 等

```c
async int read(int n) {
    // read data...
    return n;
}

async int f() {
    int x = await read(2) + 3; // expected-error {{await expression is not allowed to appear in binary operator expression}}
    int y = await read(2); // support
    return 0;
}
```

11. `await` 表达式支持 `await` 多层嵌套调用

```c
async int test0(int n) {
    // read data...
    return n;
}

async int test1(int n) {
    // ...
    return n;
}

async int test2(int n) {
    // ...
    return n;
}

async int test3(int n1, int n2) {
    // ...
    return 0;
}

async int f() {
    int start = 0;
    int result1 = await test1(await test1(start));
    int result2 = await test1(await test2(start));
    int result3 = await test3(2, await test1(await test2(start)));
    return result1 + result2 + result3;
}
```

12. `await` 表达式可以出现在 return 语句中

```c
async int read(int n) {
    // read data...
    return n;
}

async int f() {
    return await read(2);
}
```

### 代码样例

```c
# include "future.hbs"
const int MAX = 3;

async int read(int a) {
    return 0;
}

async int f() {
    int *nptr = NULL;
    int  var[] = {10, 100, 200};
    int  i, *ptr;

    ptr = &var[MAX-1];
    for ( i = MAX; i > 0; i--)
    {
    ptr--;
    }
    int result = await read(1);
    result += *ptr;
    return result;
}

async void g(int start) {
    int result = start;
    for (int i = 0; i< start; i++) {
        int a = await f();
    }
}

int main() {
    trait Future<int>* this1 = f();
    this1->poll();
    this1->free();
    // 当 async 函数的返回类型是 void 时，我们需要用 struct Void 类型（会自动创建）来对 trait Future 实例化
    trait Future<struct Void>* this2 = g(5);
    this2->poll();
    this2->free();
    return 0;
}
```



------
